---
layout: single

title: "[STM32] Control Nucleo using string command"
excerpt: "Let's type string on putty to control led"

categories:
  - Firmware enginnering

tag: [STM32, USART, armKeil, nucleo, C/C++, putty, PWM] 

toc: true
toc_sticky: true

author_profile: false
sidebar:
  nav: "docs"
---

## USART2 connection 
After connecting various peripherals to the Nucleo board and performing desired tasks easily using the char data type—for instance, creating a condition like if (input == '1') to execute a specific action when the '1' key is pressed on the keyboard—what if you want to invoke a task by entering a string?—for instance, type ***"please turn on the moonlight"***

Today, we will explore that. We will send data in the form of strings to a module connected through Putty, utilizing USART communication with a speed of 115200 baut rate and a character length of 8 bits.

### Setting SMT32 CUBE_MX

There is no need for any special MX configuration to receive strings as input. However, since we are dealing with asynchronous communication with Putty, it's important to check parameters such as the length of a single character and the baud rate. The crucial step is to set up interrupts. This way, you can add the desired functionality each time input is received from the keyboard. configure USART connection as below 

![usart_speed](/assets/images/2023-11-23-stm32stringInput/usart_speed.png)

![usart_interrupt](/assets/images/2023-11-23-stm32stringInput/usart_interrupt.png)

|Basic Parameters||
|---|---|
|Baud Rate (Bit/s)|115200|
|Word Length (Bit)|8|
|Parity|None|
|Stop Biits|1|
|USART2 global interrupt|Enabled|

### &husart2 initialization
The line *MX_USART2_UART_Init();* is likely part of STM32 microcontroller code generated by STM32CubeMX or STM32CubeIDE. It initializes the USART2 module with default settings. 
```c
MX_USART2_UART_Init();
```
---

The line HAL_UART_Receive_IT(&huart2, &rx_data, 1); is a function call from the STM32Cube HAL (Hardware Abstraction Layer) library. It is used to initiate an asynchronous reception of a single byte over USART (Universal Synchronous Asynchronous Receiver Transmitter) communication on USART2.

Here's a breakdown:

- HAL_UART_Receive_IT: This is a function from the HAL library for USART reception with interrupt support.

- &huart2: It passes the handle to the USART2 peripheral to the function. The huart2 structure likely contains configuration information and the current status of the USART2 module.

- &rx_data: It specifies the memory location where the received data will be stored. In this case, it's likely a variable named rx_data.

- 1: It indicates the number of bytes to receive. In this case, it's set to 1, indicating a single byte.

This function call sets up the USART2 module to receive one byte asynchronously, and when the reception is complete, an interrupt will be triggered. The received byte will be stored in the memory location pointed to by &rx_data. This is a common pattern for handling USART communication in STM32 microcontroller projects.

```c
HAL_UART_Receive_IT(&huart2,&rx_data, 1);
```

---
The function void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) is a callback function provided by the STM32Cube HAL (Hardware Abstraction Layer) library. This specific callback is invoked when a UART (Universal Asynchronous Receiver Transmitter) reception is completed. the code below is fragile, needs to be converted as below so that we can use it on main().c file. 

```c
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
```

```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
  HAL_UART_Receive_IT(&huart2,&rx_data, 1);
}
```
>The second picture appears to be a modified version of the code from the first picture for copying and use. The meaning of "__weak" is incomplete. In the second picture, it instructs to store an 8-bit word in "rx_data" when an interrupt occurs. The "__weak file" seems to be copied from the "_it.c" file.

## Set putty 
Check the serial line of the connected STM32 board in Device Manager and confirm the baud rate we set earlier. In Putty's serial mode, input the specified baud rate and open the connection. For convenience, save these settings so that you don't have to configure them every time you use Putty. An important point here is to ***check the ASCII code for the backspace***, which is essential for programming later. The author faced significant difficulties in debugging due to not checking this part accurately. push the reset button on nucleo board to check if it works okay.


<p align="center"><img src="assets/images/2023-11-23-stm32stringInput/putty_config.gif"></p>

## Let's promgramming 

```c

uint8_t rx_data;
char rx_data_container[20] = {0,};
char rx_buffer[20] = {0,};
uint8_t BP = '\b';
uint8_t Blank = ' ';
uint8_t Return_r = '\r';
int cnt = 0;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
	if(huart->Instance == USART2){
		HAL_UART_Receive_IT(&huart2,&rx_data, 1);
		if(rx_data == '\r'){
			for(int i = 0; i<cnt;i++){HAL_UART_Transmit(&huart2, &BP,1,0xFFFF);}
			for(int i = 0; i<cnt;i++){HAL_UART_Transmit(&huart2, &Blank,1,0xFFFF);}
			HAL_UART_Transmit(&huart2, &Return_r,1,0xFFFF);
			rx_data_container[cnt] = '\0';
			memmove(rx_buffer,rx_data_container,20);
			container_Inti();
			cnt = 0;
		}else if(rx_data == 0b01111111){ //ASCII 127 - backspace
			cnt--;
			rx_data_container[cnt] = NULL;
			HAL_UART_Transmit(&huart2, &BP,1,0xFFFF);
			HAL_UART_Transmit(&huart2, &Blank,1,0xFFFF);
			HAL_UART_Transmit(&huart2, &BP,1,0xFFFF);
		}else if(rx_data != '\r'){
			rx_data_container[cnt] = rx_data;
			printf("%c", rx_data_container[cnt]);
			cnt++;
		}
	}
}
```
The provided code is written inside a callback function to implement string command handling. Despite its apparent complexity, the underlying principle is straightforward. With each keystroke on the keyboard, the 8-bit character transmitted, *rx_data*, is systematically stored in the *rx_data_container* array. When Enter is pressed, the string formed by rx_data_container + '\0' is saved in the *rx_buffer*.
```c
if(strcmp(rx_buffer,"moonlight on") == 0)
```

Additionally, if *rx_data* satisfies certain conditions specified in the following if statements, the Nucleo board initiates the corresponding tasks.

## Here we see how it works

If the command "moonlight on" is entered in Putty, the LED connected to the board starts the mood light. To use the mood light conveniently, PWM (Pulse Width Modulation) needs to be employed, and the theoretical aspects of this will be addressed later.

<p align="center"><img src="assets/images/2023-11-23-stm32stringInput/outcomes.gif"></p>
